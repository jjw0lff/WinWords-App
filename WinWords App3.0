<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WinWords with Live Logs</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" />
  <style>
    body {
      font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      margin: 0;
      padding: 0;
      background-color: #f8fafc; /* Tailwind slate-50 */
    }
    .no-scrollbar::-webkit-scrollbar {
      display: none;
    }
    .no-scrollbar {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
  </style>
</head>
<body>

  <div id="root" class="min-h-screen flex items-center justify-center p-4"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // This placeholder will be replaced by Netlify's build process.
    const GROQ_API_KEY = "NETLIFY_WILL_REPLACE_THIS";

    function App() {
      const [messages, setMessages] = useState([]);
      const [input, setInput] = useState('');
      const [vibe, setVibe] = useState('Casual');

      const [harmony, setHarmony] = useState(false);
      const [emotiSense, setEmotiSense] = useState(false);
      const [drawerOpen, setDrawerOpen] = useState(false);
      const [debugOpen, setDebugOpen] = useState(false);
      const [instaHaActive, setInstaHaActive] = useState(false);
      const [suggestions, setSuggestions] = useState([]);
      const [isLoading, setIsLoading] = useState(false);
      const [logs, setLogs] = useState([]);

      const messagesEndRef = useRef(null);
      const debounceTimerRef = useRef(null);
      const controllerRef = useRef(null);
      const logsEndRef = useRef(null);

      // Groq configuration
      const modelId = "llama-3.1-8b-instant"; // Fast and good model for rewriting
      const vibes = ["Casual", "Professional", "Playful", "Persuasive"];

      const jokes = [
        "Why don't scientists trust atoms? Because they make up everything.",
        "I told my wife she was drawing her eyebrows too high. She looked surprised.",
        "Why did the scarecrow win an award? Because he was outstanding in his field.",
        "I threw a boomerang a few years ago. I now live in constant fear.",
        "Why don't graveyards ever get overcrowded? People are dying to get in.",
        "I told my computer I needed a break, and it went to sleep.",
      ];

      const log = (msg) => {
        const timestamp = new Date().toLocaleTimeString();
        setLogs((prev) => [...prev, `[${timestamp}] ${msg}`]);
      };

      useEffect(() => {
        logsEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [logs]);

      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      const safeParseJSON = (raw) => {
        if (!raw) return null;
        try {
          return JSON.parse(raw);
        } catch (e) {
          log(`üîß JSON parse failed, attempting repair...`);
          // Try to fix common JSON issues
          let fixed = raw
            .replace(/\s*:\s*([^",}\]]+)(?=[,}\]])/g, ':"$1"') // Add quotes around unquoted values
            .replace(/,\s*}/g, '}') // Remove trailing commas
            .replace(/,\s*]/g, ']'); // Remove trailing commas in arrays
          
          try {
            return JSON.parse(fixed);
          } catch (e2) {
            log(`üîß Auto-repair failed, extracting manually...`);
            // Manual extraction as fallback
            const start = raw.indexOf("{");
            const end = raw.lastIndexOf("}");
            if (start >= 0 && end > start) {
              try {
                let extracted = raw.slice(start, end + 1);
                // More aggressive cleaning
                extracted = extracted
                  .replace(/"\s*:\s*"([^"]*)"([^",}]*)/g, ':"$1$2"') // Fix broken quotes
                  .replace(/"\s*:\s*([^",}]+)(?=[,}])/g, ':"$1"'); // Add missing quotes
                return JSON.parse(extracted);
              } catch (e3) {
                log(`üîß All parsing attempts failed`);
                return null;
              }
            }
          }
        }
        return null;
      };

      const getToneDesc = () => {
        const parts = [];
        if (harmony) parts.push("diplomatic and peaceful");
        if (vibe !== "Casual") parts.push(vibe.toLowerCase());
        return parts.length ? parts.join(", ") : "casual";
      };

      const buildPrompt = (msg, tone, emotiSense, count = 2) => {
        const emojiInstr = emotiSense ? "You may include up to 2 emoji inline per variant." : "Do NOT include emojis.";
        return `You are WinWords, a message rewriter. Rewrite the user's message in ${count} different styles while keeping the core meaning.

INPUT: "${msg}"
TONE: ${tone}
${emojiInstr}

CRITICAL FORMATTING RULES:
- Return EXACTLY ONE JSON object
- NO extra text before or after the JSON
- ALL strings must have proper quotes
- NO line breaks inside the JSON

Required format:
{"variants": [{"label":"style1", "text":"rewrite1"}, {"label":"style2", "text":"rewrite2"}], "best_index": 0}

Generate ${count} natural, conversational rewrites that sound human and match the "${tone}" tone.`;
      };

      const fetchSuggestions = async (text) => {
        if (!text) {
          setSuggestions([]);
          setIsLoading(false);
          if (controllerRef.current) controllerRef.current.abort();
          log("Input empty, cleared suggestions.");
          return;
        }

        if (controllerRef.current) {
          controllerRef.current.abort();
          log("Aborted previous fetch.");
        }
        controllerRef.current = new AbortController();
        setIsLoading(true);
        log(`üöÄ Fetching suggestions via Groq API for: "${text}" with tone "${getToneDesc()}" and emotiSense=${emotiSense}`);

        try {
          const apiKey = GROQ_API_KEY;
          if (!apiKey || apiKey === "NETLIFY_WILL_REPLACE_THIS") {
            log("‚ùå Groq API key missing or placeholder. Cannot fetch.");
            setSuggestions([{ label: "API Key Missing", text: "The API key was not set during deployment." }]);
            setIsLoading(false);
            return;
          }

          const prompt = buildPrompt(text, getToneDesc(), emotiSense, 2);
          const payload = {
            model: modelId,
            messages: [{ role: "user", content: prompt }],
            temperature: 0.7,
            max_tokens: 400,
            top_p: 1,
            stream: false,
          };

          log(`üì° Sending request to Groq with model: ${modelId}`);
          const startTime = Date.now();

          const res = await fetch("https://api.groq.com/openai/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": "Bearer " + apiKey,
            },
            body: JSON.stringify(payload),
            signal: controllerRef.current.signal,
          });

          const endTime = Date.now();
          const responseTime = endTime - startTime;
          log(`‚ö° Groq API response received in ${responseTime}ms`);

          if (!res.ok) {
            const txt = await res.text();
            log(`‚ùå Groq API error ${res.status}: ${txt}`);
            setSuggestions([{ label: "API Error", text: `Error ${res.status}: ${txt.substring(0, 100)}` }]);
            setIsLoading(false);
            return;
          }

          const json = await res.json();
          const raw = json?.choices?.[0]?.message?.content ?? json?.choices?.[0]?.text;
          log(`üìù Raw response from Groq: ${raw.substring(0, 200)}${raw.length > 200 ? "..." : ""}`);

          // Log token usage if available
          if (json.usage) {
            log(`üìä Token usage - Prompt: ${json.usage.prompt_tokens}, Completion: ${json.usage.completion_tokens}, Total: ${json.usage.total_tokens}`);
          }

          const parsed = safeParseJSON(raw);
          if (!parsed || !Array.isArray(parsed.variants)) {
            log("‚ö†Ô∏è Failed to parse variants JSON, showing raw text.");
            setSuggestions([{ label: "Suggestion", text: String(raw).trim() }]);
          } else {
            log(`‚úÖ Successfully parsed ${parsed.variants.length} variants.`);
            const newSuggestions = parsed.variants.slice(0, 3).map((v, i) => ({
              label: v.label || `Style ${i + 1}`,
              text: (v.text || "").trim(),
            }));
            setSuggestions(newSuggestions);
            
            // Log each suggestion
            newSuggestions.forEach((suggestion, i) => {
              log(`üí° Suggestion ${i + 1} [${suggestion.label}]: "${suggestion.text}"`);
            });
          }
        } catch (err) {
          if (err.name === "AbortError") {
            log("‚èπÔ∏è Fetch aborted.");
          } else {
            log(`‚ùå Unexpected fetch error: ${err.message || err}`);
          }
          setSuggestions([]);
        } finally {
          setIsLoading(false);
        }
      };

      useEffect(() => {
        if (debounceTimerRef.current) clearTimeout(debounceTimerRef.current);
        
        const trimmedInput = input.trim();
        const wordCount = trimmedInput.split(/\s+/).filter(word => word.length > 0).length;
        
        // Only fetch suggestions if:
        // 1. Input has at least 2 words, OR
        // 2. Input has 1 word but is at least 4 characters long, OR  
        // 3. Input ends with punctuation (complete thought)
        const shouldFetch = trimmedInput && (
          wordCount >= 2 || 
          (wordCount === 1 && trimmedInput.length >= 4) ||
          /[.!?]$/.test(trimmedInput)
        );
        
        if (shouldFetch) {
          debounceTimerRef.current = setTimeout(() => {
            fetchSuggestions(input);
          }, 800); // Increased delay to 800ms for more typing
        } else {
          setSuggestions([]);
          if (trimmedInput) {
             log(`‚è∏Ô∏è Skipping fetch - needs more words (current: ${wordCount} words, ${trimmedInput.length} chars)`);
          }
        }
        
        return () => clearTimeout(debounceTimerRef.current);
      }, [input, vibe, harmony, emotiSense]);

      const handleSendMessage = () => {
        const text = input.trim();
        if (!text) return;
        setMessages((prev) => [...prev, { id: Date.now(), type: "user", text }]);
        setInput("");
        setSuggestions([]);
        log(`üì§ User sent message: "${text}"`);
      };

      const handleAcceptSuggestion = (text) => {
        setInput(text);
        setSuggestions([]);
        log(`‚úÖ Accepted suggestion: "${text}"`);
      };

      const handleInstaHa = async () => {
        setInstaHaActive(true);

        try {
          const apiKey = GROQ_API_KEY;
          if (!apiKey || apiKey === "NETLIFY_WILL_REPLACE_THIS") {
            log("‚ùå Groq API key missing or placeholder. Cannot fetch joke.");
            setInput("Please set your Groq API key to get InstaHa jokes.");
            setInstaHaActive(false);
            return;
          }

          log("ü§£ Fetching AI-generated InstaHa joke...");
          
          const jokeTypes = [
            "Tell me a witty one-liner joke",
            "Give me a clever pun or wordplay joke", 
            "Share a funny observation about everyday life",
            "Tell me an absurd or surreal short joke",
            "Give me a mildly dark humor joke",
            "Share a silly dad joke with a twist",
            "Tell me a joke about technology or modern life",
            "Give me a random funny thought or quip"
          ];
          
          const randomType = jokeTypes[Math.floor(Math.random() * jokeTypes.length)];
          const randomSeed = Math.floor(Math.random() * 10000);
          
          const payload = {
            model: modelId,
            messages: [{ 
              role: "user", 
              content: `${randomType}. Keep it clean, under 20 words, and make it original. Random seed: ${randomSeed}` 
            }],
            temperature: 1.0, // Maximum creativity
            max_tokens: 60,
            top_p: 0.9,
            stream: false,
          };

          const res = await fetch("https://api.groq.com/openai/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": "Bearer " + apiKey,
            },
            body: JSON.stringify(payload),
          });

          if (!res.ok) {
            const txt = await res.text();
            log(`‚ùå Groq API error ${res.status}: ${txt}`);
            setInstaHaActive(false);
            return;
          }

          const json = await res.json();
          let joke = json?.choices?.[0]?.message?.content?.trim() || "No joke found.";
          
          // Clean up the joke response
          joke = joke.replace(/^["']|["']$/g, ''); // Remove quotes
          joke = joke.replace(/^(Here's a joke:|Here's one:|Sure!|Okay!)\s*/i, ''); // Remove prefixes
          
          setInput(joke);
          log(`üòÇ InstaHa joke (${randomType}): "${joke}"`);
        } catch (err) {
          log(`‚ùå InstaHa error: ${err.message || err}`);
        }

        setTimeout(() => setInstaHaActive(false), 1000);
      };

      const handleCycleVibe = () => {
        const currentIndex = vibes.indexOf(vibe);
        const newVibe = vibes[(currentIndex + 1) % vibes.length];
        setVibe(newVibe);
        log(`üé® Vibe changed to ${newVibe}`);
      };

      return (
        <div className="flex flex-row p-4 gap-4 justify-center min-h-[760px] max-w-full">
          {/* Main app */}
          <div className="relative rounded-3xl bg-white shadow-2xl border border-slate-200 overflow-hidden w-full max-w-sm flex flex-col">
            <div className="px-4 py-3 border-b flex items-center justify-center bg-gradient-to-r from-white via-sky-50 to-white">
              <div className="flex items-center gap-2">
                <svg className="w-8 h-8 text-blue-600" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                  <polyline points="14,2 14,8 20,8" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                  <path d="M16 13H8" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                  <path d="M16 17H8" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                  <polyline points="10,9 9,9 8,9" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                </svg>
                <span className="text-xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                  WinWords
                </span>
              </div>
            </div>

            <div className="p-4 pb-28 h-[560px] overflow-y-auto flex-grow flex flex-col gap-3 no-scrollbar">
              {messages.length === 0 ? (
                <div className="mt-6 text-center text-slate-400">
                  No messages yet ‚Äî type below to try your vibe.
                </div>
              ) : (
                messages.map((m) => (
                  <div
                    key={m.id}
                    className={`max-w-[78%] ${
                      m.type === "user"
                        ? "self-end bg-blue-600 text-white"
                        : "self-start bg-slate-100 text-slate-900"
                    } rounded-lg p-3 shadow-sm whitespace-pre-wrap`}
                  >
                    {m.text}
                  </div>
                ))
              )}
              <div ref={messagesEndRef} />
            </div>

            <div className="absolute bottom-0 left-0 right-0 bg-white border-t p-3 flex flex-col gap-2">
              <div className="px-1 mb-1">
                <div className="flex gap-2 items-center overflow-x-auto no-scrollbar" style={{ WebkitOverflowScrolling: "touch" }}>
                  {isLoading && suggestions.length === 0 ? (
                    <div className="w-24 h-8 bg-gradient-to-r from-slate-100 via-slate-200 to-slate-100 rounded-full animate-pulse"></div>
                  ) : (
                    suggestions.map((s, index) => (
                      <div
                        key={index}
                        className="flex items-center gap-2 bg-white border rounded-full shadow-sm px-3 py-1 min-w-max transition-transform transform hover:scale-105"
                      >
                        <button
                          onClick={() => handleAcceptSuggestion(s.text)}
                          className="text-xs text-slate-700 pr-1 text-left"
                        >
                          {s.text.length > 60 ? s.text.slice(0, 57) + "‚Ä¶" : s.text}
                        </button>
                      </div>
                    ))
                  )}
                </div>
              </div>

              {/* Feature controls bar */}
              <div className="flex items-center justify-between px-2 py-2 bg-slate-50 rounded-xl mb-2">
                <div className="flex items-center gap-4">
                  {/* Vibe selector */}
                  <button
                    onClick={handleCycleVibe}
                    className="flex items-center gap-1 text-sm font-medium transition-colors hover:bg-white hover:shadow-sm px-2 py-1 rounded-lg"
                  >
                    <span className="text-purple-600">Vibe</span>
                    <span className="text-slate-700 font-semibold">{vibe}</span>
                    {harmony && <span className="text-purple-600 ml-1">Harmony</span>}
                  </button>

                  {/* Harmony toggle */}
                  <button
                    onClick={() => {
                      setHarmony(!harmony);
                      log(`üïäÔ∏è Harmony set to ${!harmony}`);
                    }}
                    className={`text-lg transition-all duration-200 hover:scale-110 ${
                      harmony ? 'grayscale-0' : 'grayscale filter opacity-40'
                    }`}
                    title="Harmony Mode"
                  >
                    ‚òÆÔ∏è
                  </button>

                  {/* EmotiSense toggle */}
                  <button
                    onClick={() => {
                      setEmotiSense(!emotiSense);
                      log(`üòä EmotiSense set to ${!emotiSense}`);
                    }}
                    className="text-lg hover:scale-110 transition-transform"
                    title="EmotiSense"
                  >
                    {emotiSense ? 'üòÅ' : 'ü´•'}
                  </button>

                  {/* InstaHa button */}
                  <button
                    onClick={handleInstaHa}
                    className={`text-lg hover:scale-110 transition-all duration-200 ${
                      instaHaActive ? 'animate-bounce' : ''
                    }`}
                    title="InstaHa!"
                  >
                  üé≠
                  </button>
                </div>

                {/* Debug toggle */}
                <button
                  onClick={() => setDebugOpen(!debugOpen)}
                  className={`text-lg hover:scale-110 transition-all ${
                    debugOpen ? 'opacity-100' : 'opacity-30'
                  }`}
                  title="Debug Panel"
                >
                  üóÑÔ∏è
                </button>
              </div>

              <div className="flex items-center gap-3 relative">
                <input
                  type="text"
                  placeholder="Type a message..."
                  className="flex-1 px-4 py-3 rounded-full border focus:outline-none focus:ring-2 focus:ring-sky-200 transition"
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  onKeyDown={(e) => e.key === "Enter" && handleSendMessage()}
                />

                <button
                  onClick={handleSendMessage}
                  className="w-12 h-12 rounded-xl bg-gradient-to-br from-blue-600 to-indigo-600 text-white flex items-center justify-center shadow-md"
                  aria-label="Send message"
                >
                  <svg className="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path d="M22 2L11 13" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" />
                    <path d="M22 2l-7 20-4-9-9-4 20-7z" strokeWidth="1.2" strokeLinecap="round" strokeLinejoin="round" />
                  </svg>
                </button>
              </div>
            </div>
          </div>

          {/* Debug panel - toggleable */}
          {debugOpen && (
            <div
              className="bg-black text-green-400 font-mono text-xs rounded-xl p-3 w-[320px] h-[760px] overflow-y-auto whitespace-pre-line"
              style={{ whiteSpace: "pre-wrap" }}
            >
              <div className="font-bold mb-2 text-yellow-400">üîß WinWords Debug Panel (Groq API)</div>
              <div className="text-gray-400 mb-3 text-xs">Model: {modelId}</div>
              {logs.map((logMsg, i) => (
                <div key={i} className="mb-1">{logMsg}</div>
              ))}
              <div ref={logsEndRef} />
            </div>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>

Sources
